    def run_grid_trading_strategy(
        self,
        df: pd.DataFrame,
        grid_lower_price: float = 0,
        grid_upper_price: float = 0,
        grid_num_grids: int = 10,
        grid_investment_per_grid: float = 10000
    ) -> Dict:
        """
        執行網格交易策略
        在價格區間內設置多個網格，價格下跌時買入，上漲時賣出
        修正Look-ahead Bias: 使用前一天的收盤價來判斷是否觸及網格

        Args:
            df: 股票資料 DataFrame
            grid_lower_price: 網格下限價格（0表示自動設定為最低價）
            grid_upper_price: 網格上限價格（0表示自動設定為最高價）
            grid_num_grids: 網格數量
            grid_investment_per_grid: 每個網格的投資金額

        Returns:
            回測結果字典
        """
        df = df.copy()

        # 自動設定網格範圍（如果未指定）
        if grid_lower_price == 0:
            grid_lower_price = df['close'].min() * 0.9  # 最低價的90%
        if grid_upper_price == 0:
            grid_upper_price = df['close'].max() * 1.1  # 最高價的110%

        # 計算網格價格
        grid_step = (grid_upper_price - grid_lower_price) / grid_num_grids
        grid_prices = [grid_lower_price + i * grid_step for i in range(grid_num_grids + 1)]

        print(f"   Grid range: NT${grid_lower_price:.2f} - NT${grid_upper_price:.2f}")
        print(f"   Grid step: NT${grid_step:.2f}")
        print(f"   Grid prices: {[f'{p:.2f}' for p in grid_prices[:5]]}...")

        # 初始化
        self.cash = self.initial_capital
        self.position = 0
        self.trades = []
        portfolio_values = []

        # 追蹤每個網格的狀態（是否已買入）
        grid_status = {i: False for i in range(grid_num_grids)}

        # 回測邏輯 - 修正Look-ahead Bias
        # 使用前一天的價格判斷是否觸及網格，今天以開盤價執行交易
        for i in range(len(df)):
            row = df.iloc[i]
            portfolio_value = self.cash + self.position * row['close']
            portfolio_values.append(portfolio_value)

            # 需要至少1天前的數據
            if i < 1:
                continue

            prev_row = df.iloc[i-1]
            prev_price = prev_row['close']
            current_price = row['open'] if not pd.isna(row['open']) else row['close']

            # 檢查是否觸及買入網格（價格下跌）
            for grid_idx in range(grid_num_grids):
                grid_buy_price = grid_prices[grid_idx]

                # 前一天價格低於網格價格，且該網格未買入，且有足夠資金
                if (prev_price <= grid_buy_price and
                    not grid_status[grid_idx] and
                    self.cash >= grid_investment_per_grid):

                    shares_to_buy = int(grid_investment_per_grid / current_price)
                    if shares_to_buy > 0:
                        actual_cost = shares_to_buy * current_price
                        if actual_cost <= self.cash:
                            self.cash -= actual_cost
                            self.position += shares_to_buy
                            grid_status[grid_idx] = True

                            self.trades.append({
                                'date': row['date'],
                                'action': 'BUY',
                                'price': current_price,
                                'shares': shares_to_buy,
                                'amount': actual_cost,
                                'signal': f'Grid buy at level {grid_idx} (NT${grid_buy_price:.2f})'
                            })

            # 檢查是否觸及賣出網格（價格上漲）
            for grid_idx in range(grid_num_grids):
                grid_sell_price = grid_prices[grid_idx + 1] if grid_idx < grid_num_grids else grid_upper_price

                # 前一天價格高於網格價格，且該網格已買入，且有持倉
                if (prev_price >= grid_sell_price and
                    grid_status[grid_idx] and
                    self.position > 0):

                    # 賣出該網格對應的股數（簡化：平均分配）
                    shares_to_sell = int(self.position / sum(grid_status.values()))
                    if shares_to_sell > 0:
                        revenue = shares_to_sell * current_price
                        self.cash += revenue
                        self.position -= shares_to_sell
                        grid_status[grid_idx] = False

                        self.trades.append({
                            'date': row['date'],
                            'action': 'SELL',
                            'price': current_price,
                            'shares': shares_to_sell,
                            'amount': revenue,
                            'signal': f'Grid sell at level {grid_idx + 1} (NT${grid_sell_price:.2f})'
                        })

        # 計算最終結果
        final_value = self.cash + self.position * df.iloc[-1]['close']
        metrics = self._calculate_metrics(portfolio_values, df, final_value)
        buy_hold_value = (self.initial_capital / df.iloc[0]['close']) * df.iloc[-1]['close']
        buy_hold_return = ((buy_hold_value - self.initial_capital) / self.initial_capital) * 100

        return {
            'initial_capital': self.initial_capital,
            'final_value': final_value,
            'total_return': metrics['total_return'],
            'buy_hold_return': buy_hold_return,
            'sharpe_ratio': metrics['sharpe_ratio'],
            'max_drawdown': metrics['max_drawdown'],
            'total_trades': len(self.trades),
            'winning_trades': metrics['winning_trades'],
            'losing_trades': metrics['losing_trades'],
            'win_rate': metrics['win_rate'],
            'trades': self.trades,
            'portfolio_values': portfolio_values,
            'dates': df['date'].tolist(),
            'prices': df['close'].tolist()
        }
